#############################################
# Aliases for simple moves
#############################################
alias gup=". gitsetup.sh"                     # Run startup script with 'gup': https://github.com/technicalities/comfy-git/blob/master/myBash/gitsetup.sh
alias gitbr="printf '\n' && git branch -v"
alias goma="git checkout master"
alias goback="git checkout @{-1}"
alias gotest="git checkout testing"
alias gitpl="git pull origin master"

# Prep
alias gistv="git status -v -b"
alias gdf="git diff --ignore-space-change"
alias gdfs="git diff --staged --ignore-space-change"
alias gitlast="git diff HEAD^ HEAD"
alias gitchanged="git log --name-status HEAD^..HEAD"
alias githead="git rev-parse HEAD | GREP_COLORS='ms=34;1' grep $(git rev-parse --short=0 HEAD)"
alias gitmod="git add ."

# I don't like the git diff view or kdiff: syntaxify. Open with "pipe".
alias pipephp="echo '<?php' > 'C:\\Users\\gavin.leech\\Desktop\\new_diff.php';
                git diff --ignore-space-change >> 'C:\\Users\\gavin.leech\\Desktop\\new_diff.php'"

# Emergency
alias gitboo="git blame --"
# Full functions, see section below
# gitall ()   # Add all unstaged and untracked changes:
# gitco ()    # Commit with editor popup
# gitcom ()   # Inline commit. $1 is the commit msg
# gitnew ()   # Start a new branch off master, ensuring it's current. Pass branch name.
# gitmerma () # Merge master into current:
# gitps ()    # Push current to origin:
# gitpipe ()  # Send the diff to a php marked-up file. Open with 'pipe'
# gitaarrgg() # Reset all staged changes to last commit state
# gitwipe ()  # Checkout all unstaged changes to last commit state
# gitsquash() # Merge the last $1 commits into one commit :

# Catch typos
alias gt='git '
alias gtbr='gitbr'
alias gits='gist' 
alias gitsv='gistv' 
alias gitst='gist' 
alias gitstv='gistv' 
alias gtstv='gistv'
alias gtsvt='gistv'
alias gitsvt='gistv'
alias gddf='gdf'
alias gfd='gdf'
alias gfds="gdfs"
alias gfsd="gdfs"

# Atom shortcuts
alias albums="atom 'C:\\Tooling around\\albums.md' &"
alias scratch="atom 'C:\\Desktop\\Current_commit.txt' &"
alias bashrc="atom ~/.bashrc &"
alias gitconf="atom 'C:\\.gitconfig' &"
alias snippets="atom 'C:\\.atom\\snippets.cson' &"
alias pipe="atom 'C:\\Desktop\\new_diff.php' &"

# Writing my own PS1 breaks the __git_ps1 branch autoexpand...
#export PS1=\[\033]0;$MSYSTEM:${PWD//[^[:ascii:]]/?}\007\]\n\[\033[32m\]\u@\h \[\033[33m\]\w$(__git_ps1)\[\033[0m\]\n$ 


#############################################
# Functions
#############################################

# Confirmation prompt before serious commands
confirm () {
    read -r -p "${1:-Are you sure about that? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true ;;
        *)
            echo "Command not executed. Type 'y' next time"
            false ;;
    esac
}

# Check 0-9:
confirmInt () {
    case $1 in [0-9]) 
            true ;;
        *)
            echo "Command not executed. Type a single digit next time"
            false ;;
    esac
}

# Just add a null message to clean git status calls:
gist () {
  status=$(git status -s)
    
  if [[ -z $status ]] 
      then echo "Nothing to declare."
  else
      echo $status
  fi
}

# Add all unstaged and untracked changes:
gitall () {
    confirm 'The kitchen sink?' && git add --all
}

# Commit with editor popup
gitco () {
    confirm 'Have you removed all traces?' && git commit
}

# Inline commit. $1 is the commit msg
gitcom () {
    confirm 'Have you removed all traces?' && git commit -m "$1"
}

# Start a new branch off master, ensuring it's current. Pass branch name.
gitnew () {
    confirm 'Update master and branch off it?' && goma && gitpl && git checkout -b $1
}

# Merge master into current:
gitmerma () {
    confirm 'Have you committed all yr new changes?' && git merge master
}

# Standard procedure for dealing with merge conflicts: 
gitmerhelp () {
    goma && git pull &&     # pull to 'master'
    goback && gitmerma &&   # then merge updated 'master' into troubled branch
    git mergetool &&        # and investigate
    echo "Use 'git clean -f' to rid yourself of these:" && 
    git clean -f -n         # and consider dumping those orig backups
}

# Push current to origin:
gitps () {
    confirm 'Everyone will see this' && git push origin HEAD
}

# Send the diff to a php marked-up file. Open with 'pipe'
gitpipe () {
    echo '<?php' > 'C:\\Users\\gavin.leech\\Desktop\\new_diff.php'; 
    git diff --ignore-space-change >> 'C:\\Users\\gavin.leech\\Desktop\\new_diff.php'
}

# Reset all staged changes to last commit state
gitaarrgg () {
    confirm 'Destroy all staged changes?';
    git reset --hard HEAD    
}

# Checkout all unstaged changes to last commit state
gitwipe () {
    confirm 'Wipe all unstaged changes?' && git checkout -- .
}

# Merge the last $1 commits into one commit with msg $2 :
gitsquash () {
    confirmInt $1 &&
    confirm "Merge the last $1 commits?" && 
    git reset --soft HEAD~$1 &&
    git commit -m "$2"
}

# Startup, choose your default bash wd:
# moveHome() { 
    # cd 'C:\\Users\\gavin.leech\\'
# }
# moveHome
# export HOME='C:\\Users\\gavin.leech\\'


# NOW source ~/.bashrc
